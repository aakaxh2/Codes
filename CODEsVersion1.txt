						Indian Institute of Information Technology, Allahabad
[0] Some basic points							-------------------------------------
[1] basic template
[3]. max/min value between two nodes
[4]. Entry and exit time code
[6]. THE RAT IN MAZE (Unique Grid Problem) $$$$$
[7]. SUB-MATRIX PROBLEM
[8]. Floyd-Warshall Algorithm
[9]. |||||a ki power b|||||
[10] Bubble Sort
[11] binart tree problem(find the no. of paths which have bitwise AND(&) is ODD)
[12].(i) unique grid(original matrix me values update ho rahi hai)
	(ii) $$$$$$$$$ Modified code $$$$
[13] Longest path in a tree
[14] find all the prime divisor from 1 to 1e6 (Sieve Code)
[15] LCA (find only parent of a1 and a2) (Lowest Common Ancestor)
[16] Binary Lifting (to find k-th parent fo a node in bit time) $$$
[17] Topological sort
[18] STRONGLY CONNECTED GRAPH 
[OR] Souvik's Code ( STRONGLY CONNECTED GRAPH )
[19] Show all paths from (0,0) to (n,m) in a grid (Matrix)
[20] No. of all factors of a number (1<=n<=1e18) or (1<=n<=1e9)
[21] Heap Sort
[22] Quick Sort
[23] Selestion Sort & Insertion Sort 
[23] Convert a string S to an another string R using adjacent swapping
[24] TREE construction $$$$$$$$$$$$$$$$$$$$$
[25] Two pointer method 
[26] Longest increasing subsequnce
[27] Longest common subsequence $$$$$$$$$$$$$
[28] Subset sum problem
[29] Merge_Sort
[30] Counting SORT
[31] longest palindrome substring
[32] find all permutation of an array of length n
[33] Find all permutation of n element 
[34] Bellman Ford Algorithm
[35] Counting Sort
[36] Radix Sort
[37] Prefic sum array and KMP and Z-algorithm
[38] Merge K sorted array
[39] Subaarays count for xor equal to k $$$
[40] sum of all bit till N (N<=1e9)
[41] Aggressive cows (binary search)
[42] Allocate books (binary search)
[43] Median in Matrix
[44] Union Find {https://practice.geeksforgeeks.org/problems/union-find/1/#}
[45] Distance between two point from n points (n=100000)
[46] longest arithmetic progression
[47] Rearrange string such that there is no palindrome substring 
[48] Euclidean algorithm extended
[49] Rod cutting problem DP
[50] Bipartite graph
[51] Distance between two points
[52] Sieve latest code
-------------------------


									|| ORDERED SET ||
									

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>








									[0] some points
=> stiring s;
bool val = next_permutation(s.begin(),s.end());
if(val==true) cout<<"next pemutation is : "<<s<<endl;
else cout<<"no any next permu....";

=> we get a number form sum of any subset (some of many values) of a fibonacci series. and that number has no consecutive 1's in binary representation.

=> string to int
string s="111";

stringstream to_int(s);
int x=0;
to_int>>x;

cout<<x<<endl;

 ||or||

string s="111";
int y=stoi(s);
cout<<y;



				**Catalan number :**
				
c[0]=1
c[1]=1
c[2]= c[0]*c[1] + c[1]*c[0]
c[3]= c[0]*c[2] + c[1]*c[1] + c[2]*c[0]
c[4]= c[0]*c[3] + c[1]*c[2] + c[2]*c[1] + c[3]*c[0]
And so on..

Question link related to this topic : https://leetcode.com/problems/unique-binary-search-trees/



									-------------------

							

								[9].|||||a ki power b|||||

m=1e9+7;
Calling ans=expo(a,b,m);

long long expo(long long a,long long b,long long m)
{
	if(b==0)
	return 1;
	if(b%2==0)
	return (expo((a*a)%m,b/2,m))%m;
	return (a)%m*(expo((a*a)%m,b/2,m))%m;
}
		OR

long long expo(long long a,long long b)
{
	if(b==0)
	return 1;
	if(b%2==0)
	return expo((a*a),b/2);
	return (a)*(expo((a*a),b/2));
}

		OR

long long expo(long long a,long long b)
{
	if(b==0)
	return 1;
	if(b%2==0)
	return (expo((a*a)%m,b/2))%m;
	return (a)%m*(expo((a*a)%m,b/2))%m;
}


							|||||||||a/b by inverse modulo||||||||||||
m=1e9+7;
Calling ans=a*expo(b,m-2,m);

long long expo(long long a,long long b,long long m)
{
	if(b==0)
	return 1;
	if(b%2==0)
	return (expo((a*a)%m,b/2,m))%m;
	return (a)%m*(expo((a*a)%m,b/2,m))%m;
}

		OR

long long expo(long long a,long long b)
{
	if(b==0)
	return 1;
	if(b%2==0)
	return (expo((a*a)%m,b/2))%m;
	return (a)%m*(expo((a*a)%m,b/2))%m;
}

									

			

						[14]. find all the prime divisor from 1 to 1e6 (Sieve Code)

vector<ll>v[N+1];
    fe(i,2,N)
    {
        int n1=i;
        if(n1%2==0)
        {
            while(n1>0 && n1%2==0)
            {
              v[i].push_back(2);
              n1/=2;
            }
        }
    
        for(int j=3;j<=sqrt(n1);j+=2)
        {
            if(n1%j==0)
            {
                while(n1>0 && n1%j==0)
                {
                    v[i].push_back(j);
                    n1/=j;
                }
            }
        }
        if(n1>2) v[i].push_back(n1);
    }




								[16] Binary Lifting 

NOTE : TO FIND K-th PARENT OF A NODE IN BIT TIME(USING BIT MANIPULATION)
CODE : 
vector<vector<int>>v;
    TreeAncestor(int n, vector<int>& parent) {
        
        vector<vector<int>>par(n, vector<int>(20));
        for(int i=0;i<parent.size();++i) par[i][0]=parent[i];
        
        for(int i=1;i<20;++i)
        {
            for(int j=0;j<parent.size();++j)
            {
                if(par[j][i-1]==-1) par[j][i]=-1;
                else par[j][i]=par[par[j][i-1]][i-1];
            }
        }
        swap(v,par);
    }
    
    int getKthAncestor(int node, int k) {
        
        for(int i=0;i<20;++i)
        {
            if((k>>i)&1) {
                node=v[node][i];
                if(node==-1) return -1;
            }
        }
        return node;
    }



							[20] No. of all factors of a number (1<=n<=1e18) or (1<=n<=1e9)
Complexity : n^(1/3)

CODE :

{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    
    int p[1000001]={0};
	p[0]=1;
	p[1]=1;

	for(int i=2;i*i<=1000000;i++)
	{ 
		if(p[i]==0)
		{ 
			for(int j=i*i;j<=1000000;j=j+i)
			p[j]=1;
		}
	}
	
	vector<int>v;
	for(int i=2;i<=1000000;i++)
	{ 
		if(p[i]==0)
		v.push_back(i);
	}
    
    int t;  cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        
		int ans=1;
        	for(int i=0;i<v.size();i++)
		{ 
			int l=v[i]*v[i]*v[i];
			if(l>n)
			break;
			
			int cnt = 1;
            		while(n%v[i]==0)
            		{
                  		n= n/v[i];
                  		cnt = cnt + 1;
            		}
            		ans = ans * cnt;
		}
		
		
		    	int x=sqrt(n);
			if (p[n]==0)
			{
			            ans = ans * 2;
			}
			else if (p[x]==0)
			{
			    ans = ans * 3;
			}
			else if (n != 1)
			            ans = ans * 4;
			            
			            
			    
	    cout<<ans<<endl;        
        
    }
    
}

----

								Pseudo Code :

N = input()
primes = array containing primes till 10^6
ans = 1
for all p in primes :
            if p*p*p > N:
                  break
            count = 1
            while N divisible by p:
                  N = N/p
                  count = count + 1
            ans = ans * count
if N is prime:
            ans = ans * 2
else if N is square of a prime:
            ans = ans * 3
else if N != 1:
            ans = ans * 4


						-------------------------------------------------------------------

									[21] Heap Sort

CODE :

#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define int long long
#define popcount __builtin_popcountll
#define endl "\n"

void max_heapify(int a[],int i,int n)
{
    int l,r,lar;
    l=2*i;
    r=(2*i)+1;
    
    if(l<=n && a[l]>a[i])
        lar=l;
    else
        lar=i;
        
    if(r<=n && a[r]>a[lar])
        lar=r;
    
    if(lar!=i)
    {
        swap(a[i],a[lar]);
        max_heapify(a,lar,n);
    }   
}

void build_max_heap(int a[],int n)
{
    for(int i=n/2;i>=1;i--)
        max_heapify(a,i,n);    
        
}

void heapsort(int a[],int n)
{
    build_max_heap(a,n);
    
    for(int i=n;i>=2;i--)
    {
        swap(a[1],a[i]);
        n=n-1;
        max_heapify(a,1,n);       
    }    
}


signed main() 
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    int n;
    cin>>n;
    
    int a[n+1];
    a[0]=0;
    for(int i=1;i<=n;++i) cin>>a[i];
    
    heapsort(a,n);
    
    for(int i=1;i<=n;++i) cout<<a[i]<<" ";
}

					---------------------------------------------------------------------------

									[22] Quick Sort

CODE : 

#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define int long long
#define popcount __builtin_popcountll
#define endl "\n"

int partition(int a[],int p,int r)
{
    int x=a[r];
    int i=p-1;
    for(int j=p;j<=r-1;j++)
    {
        if(a[j]<=x)
        {
            i=i+1;
            swap(a[i],a[j]);
        }
    }
    swap(a[i+1],a[r]);
    return i+1;
}

void quick_sort(int a[],int p,int r)
{
    int q=(p+r)/2;
    if(p<r)
    {
        q=partition(a,p,r);
        quick_sort(a,p,q-1);
        quick_sort(a,q+1,r);      
    }
}


signed main() 
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    int n;
    cin>>n;
    
    int a[n];
    for(int i=0;i<n;++i) cin>>a[i];
    
    quick_sort(a,0,n-1);
    
    for(int i=0;i<n;++i) cout<<a[i]<<" ";
}

					-------------------------------------------------------------



								[23] Selestion Sort & Insertion Sort 

CODE : 

					// selection sort
    for(int i=0;i<n-1;++i)
    {
        int mn=a[i];
        for(int j=i+1;j<n;++j)
        {
            if(a[j]<a[i]){
                swap(a[i],a[j]);
                break;
            }
        }
    }
    
				    // insertion sort
    for(int i=1;i<n;++i)
    {
        int x=a[i],j=i-1;
        
        while(j>=0 && a[j]>x){
            
            a[j+1]=a[j];
            j--;
        }
        a[j+1]=x;
    }

						-------------------------------------------------------------

					   	 [23] Convert a string S to an another string R using adjacent swapping

NOTE : Minimum swapping required to convert S into R.
CODE : 

#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define int long long
#define popcount __builtin_popcountll
#define endl "\n"

signed main() 
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    string s,r;
    cin>>s>>r;
    
    int i = 0, j = 0, size=s.size(); 
    int result = 0; 
  
    while (i < size) { 
        j = i; 
  
        while (s[j] != r[i]) { 
            j += 1; 
        } 
  
        while (i < j) { 
  
            char temp = s[j]; 
            s[j] = s[j - 1]; 
            s[j - 1] = temp; 
            j -= 1; 
            result += 1; 
        } 
        i += 1; 
    } 
    // return result; 
    
    cout<<result;
}


							------------------------------------------------------



								[26] Longest increasing subsequnce

Expainantion :

	Input  : arr[] = {3, 10, 2, 11}
	LIS[] = {1, 1, 1, 1} (initially)
	Iteration-wise simulation :

	arr[2] > arr[1] {LIS[2] = max(LIS [2], LIS[1]+1)=2}
	arr[3] < arr[1] {No change}
	arr[3] < arr[2] {No change}
	arr[4] > arr[1] {LIS[4] = max(LIS [4], LIS[1]+1)=2}
	arr[4] > arr[2] {LIS[4] = max(LIS [4], LIS[2]+1)=3}
	arr[4] > arr[3] {LIS[4] = max(LIS [4], LIS[3]+1)=3}

Code : 

	int n;
        cin>>n;
        
        int a[n];
        for(int i=0;i<n;++i) cin>>a[i];
        
        int lis[n+1];
        lis[0]=1;
        
        for(int i=1;i<n;++i)
        {
            lis[i]=1;
            for(int j=0;j<i;++j)
            {
                if(a[i]>a[j])
                {
                    lis[i]=max(lis[i],lis[j]+1);
                }
            }
        }
        
        int ans=-1;
        for(int i=0;i<n;++i) ans=max(ans,lis[i]);
        cout<<ans<<endl;
	
								METHOD 2ND;
								
	Code : 
	
        int n;
        cin>>n;
        
        vector<int>v(n);
        for(int i=0;i<n;++i) cin>>v[i];
	
        vector<int>lis;
        for(int i=0;i<v.size();i++)
        {
            auto it=lower_bound(lis.begin(),lis.end(),v[i]);
            if(it==lis.end())
            {
                lis.push_back(v[i]);
            }
            else
            {
                *it=v[i];
            }
        }
        
        return (int)lis.size();
	
	
	

							--------------------------------------------------------


								[27] Longest common subsequence $$$$$$$$$$$$$


Note : print lenght and subsequence

CODE :

#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define int long long
#define popcount __builtin_popcountll
#define endl "\n"

signed main() 
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    // int t;  cin>>t;
    // while(t--)
    {
        string s1,s2;
        cin>>s1>>s2;
        
        int n=s1.size(),m=s2.size();
        
        int dp[n+2][m+2];
        for(int i=0;i<=n;++i)
        {
            for(int j=0;j<=m;++j)
            {
                if(i==0 || j==0) dp[i][j]=0;
                else
                {
                    if(s1[i-1]==s2[j-1]) dp[i][j]=dp[i-1][j-1]+1;
                    else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        
	//lenght of subsequence
        cout<<dp[n][m]<<endl;
        
        
        int x=n,y=m;
        vector<char>v;
        while(1)
        {
            if(s1[x-1]==s2[y-1])
            {
                v.pb(s1[x-1]);
                x--;
                y--;
            }
            else
            {
                if(dp[x-1][y]>dp[x][y-1]){
                    x--;
                }
                else{
                    y--;
                }
            }
            if(x==0 || y==0) break;
        }
        
	// print subsequence itself
        for(int i=v.size()-1;i>=0;i--) cout<<v[i];
        cout<<endl;
    }
}

							----------------------------------------------------

								     [28] Subset sum problem

Note : It is given, an array 'a' of 'n' size and a value 'k'. We have to find is there any subset possible, whose sum is equal to k or not, in array 'a'.

CODE : 

signed main() 
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    int dp[6][12];
    for(int i=0;i<6;++i) dp[i][0]=1;
    for(int i=1;i<12;++i) dp[0][i]=0;
    
    // int t;  cin>>t;
    // while(t--)
    {
        int n,k;
        cin>>n>>k;
        
        int a[n];
        for(int i=0;i<n;++i) cin>>a[i];
        
        for(int i=1;i<=n;++i)
        {
            for(int j=1;j<=k;++j)
            {
                if(a[i-1]<=j)
                    dp[i][j]=dp[i][j-a[i-1]]|dp[i-1][j];
                else
                    dp[i][j]=dp[i-1][j];
            }
        }
        
        cout<<dp[n][k]<<endl;
    }
}


OUTPUT is : True or False (0 or 1 || Yes or Not)

							-----------------------------------------------

								[29] Merge_Sort
CODE :

void Merge(int a[], int l, int mid, int r)
{
    int n=mid-l+1,m=r-mid;
    int larr[n],rarr[m];
    
    for(int i=0;i<n;++i) larr[i]=a[l+i];
    for(int i=0;i<m;++i) rarr[i]=a[mid+1+i];
    
    int i=0,j=0,k=l;
    
    while(i<n && j<m)
    {
        if(larr[i]<=rarr[j])
        {
            a[k]=larr[i];
            i++;
        }
        else{
            a[k]=rarr[j];
            j++;
        }
        k++;
    }
    
    while(i<n){
        a[k]=larr[i];
        i++; k++;
    }
    
    while(j<m){
        a[k]=rarr[j];
        j++; k++;
    }
}

void Merge_Sort(int a[],int l, int r)
{
    if(l<r)
    {
        int mid=(l+r)/2;
        Merge_Sort(a,l,mid);
        Merge_Sort(a,mid+1,r);
        Merge(a,l,mid,r);
    }
    else return;
}

signed main() 
{IOS;
    
    // int t;  cin>>t; while(t--)
    {
        int n;
        cin>>n;
        
        int a[n];
        for(int i=0;i<n;++i) cin>>a[i];
        
        Merge_Sort(a,0,n-1);
        
        for(int i=0;i<n;++i) cout<<a[i]<<" "; cout<<endl;
    }
}

							-----------------------------------------------


								[30] Counting SORT
Note : hashing method is used here.
CODE :
{
        int n;
        cin>>n;
        
        int a[n],mn=10000;
        for(int i=0;i<n;++i) { cin>>a[i]; mn=min(mn,a[i]); }
        
        int b[100]={0};
        for(int i=0;i<n;++i) b[a[i]-mn]++;
        for(int i=1;i<100;++i) b[i]+=b[i-1];
        
        int c[100]={0};
        for(int i=0;i<n;++i){
            c[b[a[i]-mn]-1]=a[i];
            b[a[i]-mn]--;
        }
        
        for(int i=0;i<n;++i) a[i]=c[i];
        
        for(int i=0;i<n;++i) cout<<a[i]<<" "; cout<<endl;
}

						---------------------------------------------------------

								[31] longest palindrome substring
CODE :

	int n;
        cin>>n;
        
        string s; cin>>s;
        
        int h[n][n]={0};
        
        int shuru=0,len=1;
        for(int i=0;i<n;++i) h[i][i]=1;
        for(int i=0;i<n-1;++i){
            if(s[i]==s[i+1]){
                h[i][i+1]=1;
                shuru=i; len=2;
            }
        }
        
        for(int l=3;l<=n;++l)
        {
            for(int i=0;i<n-l+1;++i)
            {
                int end=i+l-1;
                
                if(s[i]==s[end] && h[i+1][end-1]==1){
                    h[i][end]=1;
                    
                    shuru=i;
                    len=l;
                }
            }
        }
        
        cout<<shuru<<" "<<len<<endl;
        for(int i=shuru;i<shuru+len;++i) cout<<s[i]; cout<<endl;
	
									[ OR ]
	
Code  : 
	int n=s.length();
        vector<vector<int>>dp(n+1,vector<int>(n+1,0));
        int ans=1;
        for(int i=0;i<n-1;i++)
        {
            dp[i][i]=1;
            dp[i+1][i+1]=1;
            if(s[i]==s[i+1])
            {
                dp[i][i+1]=2;
                ans=max(ans,dp[i][i+1]);
            }
            else dp[i][i+1]=1;
        }
        
        
        for(int j=3;j<=n;j++)
        {
            for(int i=0;i<=n-j;i++)
            {
                if(s[i]==s[i+j-1])
                {                
                    dp[i][i+j-1]=dp[i+1][i+j-2]+2;
                    ans=max(ans,dp[i][i+j-1]);
                }
                else dp[i][i+j-1]=max(dp[i+1][i+j-1],dp[i][j+i-2]);
            }
        }
        
        return ans;
	

							-----------------------------------------------------

						[32] find all permutation of an array of length n
NOTE : there are n! combination.

Code :
#include <bits/stdc++.h>
using namespace std;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define int long long
#define pb push_back

int n,a[100];

void fun(int l, int r)
{
    // if(l<r) return ;
    if(l==r){
        for(int i=0;i<n;++i) cout<<a[i]<<" "; cout<<endl;
    }
    else{
        for(int j=l;j<=r;++j)
        {
            swap(a[l],a[j]);
            
            fun(l+1,r);
            
            swap(a[l],a[j]);
        }
    }
}

signed main() 
{IOS;
    
    // int t;  cin>>t; while(t--)
    {
        // int n;
        cin>>n;
        
        // int a[n];
        for(int i=0;i<n;++i) cin>>a[i];
        
        fun(0,n-1);
    }
}

								------------------------------

							[33] Find all permutation of n element 
Code : 
#include <bits/stdc++.h>
using namespace std;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define int long long
#define pb push_back

vector<int>per;
int cnt=0;

int fun(int n)
{
	if((int)per.size()==n)
	{
		cnt++;
		cout<<"permutation #"<<cnt<<": ";
        	for(int i=0;i<n;++i) cout<<per[i]<<" "; cout<<endl;
		return 0;
	}


	for(int i=1;i<=n;++i)
	{
		int flag=0;
		for(int j=0;j<per.size();++j){
			if(per[j]==i) flag++;
		}
		if(flag>0) continue;

		per.pb(i);
		fun(n);
		per.pop_back();
	}
}

signed main() 
{IOS;
    
    // int t;  cin>>t; while(t--)
    {
        int n;
        cin>>n;

		for(int i=1;i<=n;++i){
			per.pb(i);
			fun(n);
			per.pop_back();
		}
    }
}

								-----------------------------------


								[36] Radix Sort

NOTE : same as counting sort, jonly 2 or 3 more lines are added. 	TIME COMPLEXITY : (total digits in mx)*n

CODE : 

#include <bits/stdc++.h>
using namespace std;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define int long long
#define pb push_back
const int N=100005;

int fun(int a[], int n)
{
    int mx=a[0];
    for(int i=1;i<n;++i) mx=max(mx,a[i]);
    return mx;
}

void counting(int a[], int n, int ex)
{
    int cnt[10]={0};
    for(int i=0;i<n;++i) cnt[(a[i]/ex)%10]++;
    for(int i=1;i<10;++i) cnt[i]+=cnt[i-1];
    
    int h[n];
    for(int i=n-1;i>=0;i--)
    {
        h[cnt[(a[i]/ex)%10]-1]=a[i];
        cnt[(a[i]/ex)%10]--;
    }
    
    for(int i=0;i<n;++i) a[i]=h[i];
}

signed main() 
{IOS;
    
    int n;
    cin>>n;
    
    int a[n];
    for(int i=0;i<n;++i) cin>>a[i];
    
    // --
    
    int mx=fun(a,n);
    
    for(int i=1;(mx/i)>0;i*=10)
    {
        counting(a,n,i);
    }
    
    for(int i=0;i<n;++i) cout<<a[i]<<" ";
    cout<<endl;
}



									-----------------------

								      [37] Prefix sum array && KMP

Note : s[0...i]==s[n-i-1....n-1]; prefix len==suffix len
Code : 
    string s;
    cin>>s;
    
    int n=s.size();
    int pre[n]={0};
    int j;
    
    for(int i=1;i<n;++i)
    {
        int j=pre[i-1];
        
        while(j>0 && s[i]!=s[j]) j=pre[j-1];
        
        if(s[i]==s[j]) j++;
        pre[i]=j;
    }
    
    for(int i=0;i<n;++i) cout<<pre[i]<<" ";


      							  	      || Z - Algorithm ||

// KMP [ find if the r is present in s or not, if exist then return all starting index of where from r is starting ]
// Ex. : s=kakashi,r=ka
// OP : 0,2


    string r;
    cin>>r;
    
    int i=0;
    j=0;
    
    while(i<s.size())
    {
        if(s[i]==r[j]) {
            i++;
            j++;
        }
        else
        {
            if(j==0) i++;
            else j=pre[j-1];
        }
        
        if(j==r.size())
        {
            cout<<(i-r.size())<<" ";
            j=pre[j-1];
        }
    }


									[ Perfect Z-algorithm ]

code : 
string s,r;
        cin>>s;
        cin>>r;
        
        string tmp=r;
        tmp+='#';
        tmp+=s;
        s=tmp;
        
        cout<<s<<endl;
        
        int n=s.size();
        int pre[n]={0};
        int j;
        
        for(int i=0;i<r.size();++i) pre[i]=i;
        for(int i=r.size()+1;i<n;++i)
        {
            int j=pre[i-1];
            
            while(j>0 && s[i]!=s[j]) j=pre[j-1];
            
            if(s[i]==s[j]) j++;
            pre[i]=j;
        }
        
        for(int i=0;i<n;++i) cout<<pre[i]<<" ";
        cout<<endl;
        
        // finding part
        
        int i=r.size()+1;
        j=0;
        
        while(i<s.size())
        {
            if(s[i]==r[j]) {
                i++;
                j++;
            }
            else
            {
                if(j==0) i++;
                else j=pre[j-1];
            }
            
            if(j==r.size())
            {
                // cout<<(i-r.size()-r.size()-1)<<" ";
                cout<<(i-r.size())<<" ";
                j=pre[j-1];
            }
        }
        

input : s=kakashi
	r=ka
	modifieg s=ka#kakahsi

output : print s(modified) = ka#kakashi
	 (prefix and suffix alogs) = 0 1 0 1 2 1 2 0 0 0 
	 ans = 3 5 (starting point of r form where it(r) is starting in s).
    

									-----------------------


								[38] Merge K sorted Array

code : 
#include <bits/stdc++.h>
using namespace std;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define int long long
#define pb push_back

vector<int> merge(vector<int>v1, vector<int>v2)
{
    vector<int>cr;
    int i=0,j=0;
    while(i<v1.size() && j<v2.size())
    {
        if(v1[i]<=v2[j])
        {
            cr.pb(v1[i]);
            i++;
        }
        else {
            cr.pb(v2[j]);
            j++;
        }
    }
    while(i<v1.size()) cr.pb(v1[i]),i++;
    while(j<v2.size()) cr.pb(v2[j]),j++;

    return cr;
}

vector<int> fun(vector<vector<int> >v, int l, int r)
{
    vector<int>cr;
    if(r-l>1)
    {
        int mid=(l+r)/2;
        vector<int>v1=fun(v,l,mid);
        vector<int>v2=fun(v,mid+1LL,r);
        cr=merge(v1,v2);
    }
    else{
        if(r==l) {
            for(int i=0;i<(int)v[0].size();++i) cr.pb(v[l][i]);
        }
        else{
            cr=merge(v[l],v[r]);
        }
    }
    return cr;
}

signed main() 
{IOS;
    
	#ifndef ONLINE_JUDGE
		freopen("input.txt","r",stdin);
		freopen("output.txt","w",stdout);
	#endif
	
    // --
    
    int n,m;
    cin>>n>>m;

    vector<vector<int> >v(n, vector<int>(m));
    for(int i=0;i<n;++i) {
        for(int j=0;j<m;++j) cin>>v[i][j];
    }

    vector<int>ans=fun(v,0,n-1);

    for(int i=0;i<ans.size();++i) cout<<ans[i]<<" ";
    cout<<endl;
}

									------------
									
								[39] count of subarrays which have xor eq to k
Note : 

xr=prefix_xor of arr
y^k=xr
OR
y=xr^k

<------xr------------>
------|---------------
<--y-> <----k-------->

we have to count these y for every xr

Code :
int Solution::solve(vector<int> &A, int k) {

    map<int,int>mp;

    int xr=0;
    int cnt=0;
    for(int i=0;i<A.size();++i)
    {
        xr^=A[i]; // prefix_xor

        if(xr==k) cnt++; // if prefix_xor eq to k then cnt++ means here len of y is 0

        cnt+=mp[xr^k]; // y=xr^k; count of y's
        mp[xr]++; // update count of y in hash
    }

    return cnt;
}
									-----------------

								[40] sum of all bit till N (N<=1e9)
NOTE : 0<= i <arr.size()
[i]   first we make bit array for n
[ii]  loop through array and stop at every set bit 1
[iii] flip that i-th bit from 1 to 0, then we have choices to mark every bit either 0 or 1 from 0 to i-1, this will make total 2^(i) combinations
[iv]  total number of 1's in 2^(i) combinations are (2^(i-1))*i
[v]   if there are bits in array after i-th index, those will be count parallelly with (2^(i-1))*i, and their count will be (2^i)*(count of bits after i-th index)

Link : https://www.interviewbit.com/problems/count-total-set-bits/ 
code : 
#define pb push_back

long long int mod=1e9+7;
long long expo(long long a,long long b)
{
	if(b==0)
	return 1;
	if(b%2==0)
	return (expo((a*a)%mod,b/2))%mod;
	return (a)%mod*(expo((a*a)%mod,b/2))%mod;
}

int Solution::solve(int n) {

    long long y=__builtin_popcountll(n);
        
        vector<int>v;
        while(n) {
            v.pb(n%2);
            n/=2;
        }
        
        long long sum=y;
        for(int i=0;i<v.size();++i)
        {
            if(v[i]==1)
            {
                y--;
                long long x=i;
                long long int z=(expo(2,x-1)%mod*x%mod)%mod;
                long long int z1=(y%mod*expo(2,x)%mod)%mod;
                z=(z1%mod+z%mod)%mod;
                sum=(sum%mod+z%mod)%mod;
            }
        }

        return sum;
}


									-----------------------
									
									
							[41] Aggressive cows (https://www.spoj.com/problems/AGGRCOW/)
							
Note : Farmer John has built a new long barn, with N (2 <= N <= 100,000) stalls. The stalls are located along a straight line at positions x1,...,xN (0 <= xi <= 1,000,000,000).
His C (2 <= C <= N) cows don't like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ wants to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance?
code : 
bool check(int mn, vector<int>&v, int c)
{
    int lst=v[0];
    int cnt=1;
    for(int i=1;i<v.size();++i)
    {
        if(v[i]-lst>=mn)
        {
            lst=v[i];
            cnt++;
        }
        
        if(cnt>=c) break;
    }
    
    if(cnt>=c) return true;
    return false;
}

signed main() 
{IOS;
    
    int t;  cin>>t; while(t--)
    {
        
       int n,c;
       cin>>n>>c;
       
       vector<int>v(n);
       for(int i=0;i<n;++i) cin>>v[i];
       sort(v.begin(), v.end());
       
       int l=1, r=1e9;
       int ans=-1;
       while(l<=r)
       {
           int mid=(l+r)/2;
           if(!check(mid, v, c))
           {
               r=mid-1;
           }
           else {
               ans=mid;
               l=mid+1;
           }
       }
       cout<<ans<<endl;
        
    }
}
									------------------------
									
									[42] Allocate books
									
Note : https://www.interviewbit.com/problems/allocate-books/
code : 
bool check(int barrier, vector<int>&v, int k)
{
    int sum=0;
    int cnt=1;
    for(int i=0;i<v.size();++i)
    {
        if(v[i]>barrier) return false;
        if(sum+v[i]>barrier)
        {
            sum=v[i];
            cnt++;
        }
        else
        {
            sum+=v[i];
        }
    }
    
    if(cnt<=k) return true;
    return false;
}


int Solution::books(vector<int> &v, int B) {
    
    int l=0, r=0;
    int n=v.size();
    if(B>n) return -1;
    
    for(int i=0;i<n;++i)
    {
        l=min(l,v[i]);
        r+=v[i];
    }
    
    int ans=-1;
    while(l<=r)
    {
        int mid=(l+r)/2;
        
        if(check(mid,v,B))
        {
            ans=mid;
            r=mid-1;
        }
        else l=mid+1;
    }
    
    return ans;
}
									-------------------
									
									[43] Median in Matrix
Code : 
int fun(vector<int>&v, int x)
{
    int l=0,r=v.size()-1;
    while(l<=r)
    {
        int mid=(l+r)/2;
        
        if(v[mid]<=x)
        {
            l=mid+1;
        }
        else {
            r=mid-1;
        }
    }
    return l;
}

int Solution::findMedian(vector<vector<int> > &v) {
    
    int n=v.size(), m=v[0].size();
    long long int l=0, r=1e9;
    int k=(n*m)/2;
    
    while(l<=r)
    {
        long long int mid=(l+r)/2;
        
        int cnt=0;
        for(int i=0;i<n;++i)
        {
            cnt+=fun(v[i],mid);
        }
        
        if(cnt<=k)
        {
            l=mid+1;
        }
        else {
            r=mid-1;
        }
    }
    
    return l;
}
									--------------------
									
									[44] Union find $$$$
									
Code : 
#define int long long
#define pb push_back
#define endl "\n"
#define meme(dp, val) memset(dp, val, sizeof(dp))

const int N=100005;
int par[N];
int rk[N];

int find_parent(int x)
{
    if(x==par[x]) return x;
    return par[x]=find_parent(par[x]);
}

// connect x and y 
// rk[i] is height of the tree/subtree of i
// rk[x]=rk[y] => merge anyone to anyone
// rk[x]<rk[y] => merge x with y means now root will be y
// rk[x]>rk[y] => merge y with x means now root will be x

// add little tree to larger tree to reduce overall height, if we add larger tree to smaller then overall tree height will be increse
// else add smaller tree to larger will not affect overall height of the tree.

void union_(int x, int y)
{
    x=find_parent(x);
    y=find_parent(y);
    
    if(rk[x]<rk[y]) par[x]=y;
    else
    {
        if(rk[x]>rk[y]) par[y]=x;
        else par[y]=x, rk[x]++;
    }
}

// if both's (x and y) parent are same means they are in same component

int IsConnected(int x, int y)
{
    if(find_parent(x)==find_parent(y)) return 1;
    return 0;
}

signed main()
{
    // int t; cin >> t; while (t--)
    {
    	// we are going to combining m components to make a tree of n nodes 
        int n,m;
        cin>>n>>m;
        
        meme(rk,0);
        for(int i=0;i<N;++i) par[i]=i;
        
        while(m--)
        {
            int ty;
            cin>>ty;
            
            int x,y;
            cin>>x>>y;
            
            if(ty==1) // union of x and y
            {
                union_(x,y);
            }
            else // find if x and y are in same component
            {
                if(IsConnected(x,y)) cout<<"yes"<<endl;
                else cout<<"no"<<endl;
            }
        }
        
        
    }
}
									---------------------
									
								[46] longest increasing progression
									
Code : 
int lengthOfLongestAP(int a[], int n) {
        
        if(n<=1) return n;
        int dp[n][n];
        for(int i=0;i<n;++i) dp[i][n-1]=2;
        
        int mx=2;
        for(int j=n-2;j>=1;j--)
        {
            int i=j-1, k=j+1;
            while(i>=0 && k<n)
            {
                if(a[i]+a[k]>2*a[j])
                {
                    dp[i][j]=2;
                    i--;
                }
                else
                {
                    if(a[i]+a[k]<2*a[j])
                    {
                        k++;
                    }
                    else
                    {
                        dp[i][j]=dp[j][k]+1;
                        mx=max(mx, dp[i][j]);
                        i--,k++;
                    }
                }
            }
            while(i>=0) dp[i][j]=2, i--;
        }
        
        return mx;
    }
    
									-------------------   
									
    							[47] Rearrange string such that there is no palindrome substring 
							
Code : 
bool check(string s)
{
    int n=s.size();
    for(int i=1;i<n;++i) 
    {
        if(s[i]==s[i-1]) return true;
    }
    
    for(int i=2;i<n;++i)
    {
        if(s[i]==s[i-2]) return true;
    }
    return false;
}

signed main() 
{I;O;S;
    
    int t;  cin>>t; while(t--)
    {
        int n;
        cin>>n;
        
        string s;
        cin>>s;
        
        int a[26]; meme(a,0);
        for(int i=0;i<n;++i) a[s[i]-'a']++;
        
        priority_queue<pair<int,int>>pq;
        for(int i=0;i<26;++i)
        {
            if(a[i]>0) pq.push({a[i],i});
        }
        
        string r="";
        while(pq.size())
        {
            int sz=3;
            vector<pair<int,int>>v;
	    
	    // take top three frequent chars and push them into string r and pop from pq
            while(sz--)
            {
                if(pq.size()==0) break;
                v.pb(pq.top());
                pq.pop();
            }
            
	    // decrease count 1 from all three top most chars and again puch to pq
            for(int i=0;i<v.size();++i)
            {
                r+=v[i].second+'a';
                if((v[i].first)-1>0) {
                    pq.push({v[i].first-1,v[i].second});
                }
            }
        }
        
        // if there are palindrome substrings with length 2 or 3 
        if(check(r))
        {
            cout<<"NO"<<endl;
        }
        else {
            cout<<"YES"<<endl<<r<<endl;
        }
        
        
    }
}
									------------
									
								[48] Euclidean algorithm extended
Note : 
Eq : ax+by=gcd(a,b)
find x and y ??

Code : 
int x,y;
int fun(int a, int b)
{
    if(a==0) {
        x=0, y=1;
        return b;
    }
    int gcd=fun(b%a,a);
    int x1=y-(b/a)*x;
    int y1=x;
    
    x=x1, y=y1;
    return gcd;
}


signed main() 
{
    {
        int a,b;
        cin>>a>>b;
        
        int gcd=fun(b%a,a);
        
        int x1=y-(b/a)*x;
        int y1=x;
        x=x1, y=y1;
        
        cout<<"gcd is : "<<gcd<<endl;
        cout<<"x and y is : "<<x<<", "<<y<<endl;
    }
}
									  --------------------
									  
									[49] ROd cutting problem
Code : 

#define ll long long
class Solution{
  public:
    
    unordered_map<ll,int>mp;
    
    ll cut(int a[], int n)
    {
        if(n==0) return 0;
        if(n==1) return a[0];
        
        if(mp.find(n)!=mp.end()) return mp[n];
        
        ll tmp=0;
	// make a cut of i len and take it's price and call fun for remaining n-i part
        for(int i=1;i<=n;++i)
        {
            tmp=max(tmp, a[i-1]+cut(a,n-i));
        }
        
        return mp[n]=tmp;
    }
  
  
    int cutRod(int price[], int n) {
        
        return cut(price, n);
    }
};
									------------------

									[50] Bipartite graph
									
Note : coloring graph with two different colors such that no two adjacent nodes have the same color (Hint1 : having an even length cycle is bipartite and an odd length cycle is not a bipartite graph.)

CODE : 
vector<int>col(n+1, -1);
queue<int>q;

for(int i=0;i<n;++i)
{
    if(col[i]==-1)
    {
	q.push(i);
	col[i]=0;
	while(q.size())
	{
	    int x=q.front();
	    q.pop();

	    for(int j=0;j<v[x].size();++j)
	    {
		int child=v[x][j];
		if(col[child]==col[x]) return false;
		if(col[child]==-1)
		{
		    col[child]=(col[x]+1)%2;
		    q.push(child);
		}
	    }
	}
    }
}
return true;
									---------------

								[51] Distance between two points

Note : [https://cses.fi/problemset/task/2194/]
Code : 

int sq(int x) { 
    return (x*x); 
    
}
double distance(pair<int,int>&p1, pair<int,int>&p2)
{
    return sqrt(sq(p1.first-p2.first)+sq(p1.second-p2.second));
}

double fun(vector<pair<int,int>>&v)
{
    int n=v.size();
    if(n<=1) return 2e18;
    
    vector<pair<int,int>>left(v.begin(), v.begin()+(n/2));
    vector<pair<int,int>>right(v.begin()+(n/2), v.end());
    
    double d1=fun(left);
    double d2=fun(right);
    double d=min(d1,d2);
    
    int mid=left.back().first;
    vector<pair<int,int>>stripe;
    for(auto it : left) {
        if(it.first > mid-d) stripe.pb(it);
    }
    for(auto it : right) {
        if(it.first < mid+d) stripe.pb(it);
    }
    
    sort(stripe.begin(), stripe.end(), [&](pair<int,int>&p1, pair<int,int>&p2){
        return p1.second<p2.second;
    });
    
    for(int i=0;i<(int)stripe.size();++i)
    {
        for(int j=i+1;j<(int)stripe.size() && stripe[j].second < (stripe[i].second + d) ;++j)
        {
            d=min(d, distance(stripe[i], stripe[j]));
        }
    }
    
    return d;
}


signed main() 
{I;O;S;
    
    // int tc;  cin>>tc; while(tc--)
    {
        
        int n;
        cin>>n;
        
        vector<pair<int,int>>v;
        for(int i=0;i<n;++i)
        {
            int x,y;
            cin>>x>>y;
            v.pb({x,y});
        }
        sort(v.begin(), v.end(), [&](pair<int,int>&p1, pair<int,int>&p2){
           return p1.first<p2.first;
        });
        
        double ans=fun(v);
        int x=llround(ans*ans);
        // cout<<x<<endl;
        printf("%lld\n",x);
        
    }
}


								-------------------------

								[52] Sieve code
Code : 
 	int h[N]={0};
        
        for(int i=2;i*i<N;++i)
        {
            if(h[i]==0)
            {
                for(int j=i*i;j<N;j+=i) {
                    h[j]=1;
                }
            }
        }
								------------------------



















